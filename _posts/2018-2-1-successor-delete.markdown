---
layout: post
title: "并查集的特殊应用——Successor with Delete"
date: 2018-2-1 18:31:23 +0800
categories: programming
---

本问题来自Coursera上Algorithms, Part I课程的练习测验。问题内容如下：

> 实现相应算法/数据结构，存储以{0, 1, ..., n-1}为初始元素的集合，并支持集合上删除元素和查找给定元素后继（不小于给定元素的最小元素）操作，且二者时间复杂度均为O(lg(N))。

仔细考察这个问题，可以发现一些有意思的性质：

首先，这个集合中任意一个元素的后继都是自身。这是显而易见的——比自身更小，同时又不小于自身的元素是不存在的。

另外一个性质也很有意思。如果我们从这个正整数序列上删除了连续的几个元素，那么这几个元素中任意一个的后继都是序列上随后第一个未被删除的元素。例如，令n为5，则集合一开始的样子是{0, 1, 2, 3, 4}。如果我们删除了1、2和3，集合变成了{0, 4}，那么1、2和3的后继都是4。同时，根据上一条性质，我们知道4的后继也是4。

如果将这个正整数序列想象为一个梯子，这个性质就很好理解了：如果梯子中间有些横杆断了（被删除的元素），那么踏脚上去将使脚下落，直到踩上一根完好的横杆（第一个未被删除的元素）。

对于查找后继的所有可能输入{0, 1, ..., n-1}组成的集合，根据其后继，可以得到这个集合的一个划分。例如对于刚才提到的集合{0, 4}，0在其中的后继为0，1、2、3、4在其中的后继都是4，因此我们得到了划分{\{0\}, {1, 2, 3, 4}}。

进一步观察这个划分，我们会发现，划分中每一‘块’中元素的后继就是这一‘块’中的最大值：对于只有一个元素的‘块’，事实显然如此；对于元素多于一个的‘块’，其中最大值便是序列上随后第一个未被删除的元素，是刚才提到的‘梯子上第一根完好的横杆’，是‘块’中所有元素的后继。

至此，这个问题已经可以用Union-Find算法来解决：删除元素x时，对x和x+1执行Union操作（直观上就像是x把找后继的责任交给了x+1，毕竟x已经被删除，x+1的后继就是x的后继）；在查找元素的x后继时，返回x所属的树（对应刚才提到的‘块’）中的最大值，这可以通过修改Union-Find算法维护一个额外的数组来实现。
